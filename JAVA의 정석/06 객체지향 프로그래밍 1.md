# 객체지향 프로그래밍 1
## 1. 객체지향언어
### 1.1 객체지향언어의 역사
Object Oriented Programming 객체 지향 프로그래밍   
> 객체(프로그램 동작의 주체가 되는 요소)의 관점에서 프로그래밍 하는 것을 나타낸다.

객체지향이론의 기본 개념은 실제 세계는 사물(객체)로 이루어져 있으며, 발생하는 모든 사건들은 사물간의 상호작용이다.'라는 것이다.

객체지향 이론은 기본 개념처럼 시뮬레이션 구현 과정에서 탄생한 이론이다.
맨 처음 탄생한 언어도 **Simula**라는 언어였다.

이전에는 절차 지향 프로그래밍이 있었으며, 프로세스가 함수 단위로 순서대로 진행되는 것을 의미한다.

### 1.2 객체지향언어의 특징
1. 코드의 재사용성이 높다.
2. 코드의 관리가 용이하다.
3. 신뢰성이 높은 프로그래밍을 가능하게 한다.   

> 다만 처음부터 객체지향개념에 얽매여 개발하기 보다는 기능적으로 완성 후 어떻게 하면 보다 객체 지향적으로 개선할 수 있는지 고민하는 것이 좋다.   

자바는 다음과 같은 특징이 있다.
1. 상속(Inheritance) : 부모 클래스의 변수와 메서드를 자식 클래스가 전부 물려받는 것
2. 캡슐화(Encapsulation) : 객체의 변수 및 메서드를 외부 객체가 함부로 건드리지 못하게 감싸는 개념 / getter, setter를 통해 정보를 은닉
3. 다형성(Polymorphism) : Poly(다양한) + morphism(변형,변신) 의 합성어, 하나의 객체가 여러가지 타입을 가질 수 있음을 의미한다. / 오버로딩, 오버라이딩, 업캐스팅, 다운캐스팅 등의 방법이 존재
4. 추상화(Abstraction) : 공통의 속성, 기능을 묶어 이름을 붙이는 것을 의미한다. / 추상클래스 (추상 메서드 하나 이상), 인터페이스 (추상 메서드만을 포함한 추상 클래스, 다중 상속 가능)

## 2.클래스와 객체
### 2.1 클래스와 객체의 정의와 용도
클래스의 정의 : 클래스란 객체를 정의해 놓은 것이다.   
클래스의 용도 : 클래스는 객체를 생성하는데 사용된다.   

객체의 정의 : 실제로 존재라는 것. 사물 또는 개념   
객체의 용도 : 객체가 가지고 있는 기능과 속성에 따라 다름   
유형의 객체 : 책상, 의자, 사람 등   
무형의 객체 : 수학공식, 프로그램 에러와 같은 논리나 개념   

> 클래스를 정의하고 객체를 생성하는 이유   
-> 설계도(클레스)를 잘 만들면 제품(객체)를 만드는 것이 쉽다.   

### 2.2 객체와 인스턴스
인스턴스화(instantiate) : 클래스로부터 객체를 만드는 과정   
인스턴스(instance) : 어떤 클래스로부터 만들어진 객체   
> 객체와 인스턴스    
-> 같은 의미이므로 엄격하게 구분할 필요 없이 문맥에 맞춰 사용하면 됨   
 
### 2.3 객체의 구성 요소 - 속성과 기능
> 일반적으로 객체는 다수의 속성과 기능을 갖는다.   
-> 객체는 속성과 기능의 집합, 속성과 기능은 객체의 멤버(구성원 member)   
* 속성(property) : **멤버 변수(member variable)**, 특성(attribute), 필드(field), 상태(state)
* 기능(function) : **메서드(method)**, 함수(function), 행위(behavior)
  
### 2.4 인스턴스의 생성과 사용
클래스를 선언하는 것은 설계도 작성에 불과함, 인스턴스를 생성해야 함   
```java
클래스명 변수명; // 1.
변수명 = new 클래스명(); // 2.
변수명.멤버변수 = 값; // 3.
변수명.메서드 // 4.
```
1. 클래스 타입의 참조변수를 생성함, 메모리에 참조변수를 위한 공간이 마련되지만 아직 인스턴스가 생성되지 않아 아무것도 할 수 없다.
2. new 연산자에 의해 인스턴스가 메모리의 빈 공간에 생성됨, 이때 멤버변수는 각 자료형에 해당하는 기본값으로 초기화 된다.   
   이후, 대입연산자(=)에 의해서 생성된 객체의 주소값이 참조변수에 저장된다. 이때부터 참조변수를 통해 인스턴스에 접근할 수 있으며, 인스턴스를 다루기 위해서는 참조변수가 반드시 필요함
3. 참조변수에 저장된 주소에 있는 인스턴스의 멤버변수에 값을 저장한다.   
   인스턴스의 멤버변수(속성)을 사용하려면 '참조변수.멤버변수'와 같이 하면 된다.
4. 참조변수가 참조하고 있는 인스턴스의 메서드를 호출한다.
> 인스턴스는 참조변수를 통해서만 다룰 수 있으며, 참조변수의 타입은 인스턴스의 타입과 일치해야한다.

> 같은 클래스로부터 생성되었을지라도 각 인스턴스의 멤버변수(속성)은 서로 다른 값을 가질 수 있으며, 메서드의 내용은 모든 인스턴스가 동일하다.

> 참조변수는 인스턴스의 주소값을 저장하는 것이므로, 둘 이상의 참조변수가 같은 인스턴스의 주소값을 저장하는 것은 가능하지만, 하나의 참조변수에 여러개의 인스턴스 주소값을 저장하는 것은 불가능하다.

### 2.5 객체 배열
> 객체 또한 배열로 다를 수 있다. 이를 '객체 배열'이라 한다.   
객체 배열 안에 객체가 저장되는 것이 아니라 객체의 주소가 저장된다.   
즉 객체 배열은 참조변수들을 하나로 묶은 **참조변수 배열**이다.

```java
// 1.
클래스명[] 변수명 = new 클래스명[객체배열 크기];
변수명[배열 인덱스] = new 클래스명();
// 2.
클래스명[] 변수명 = {new 클래스명(), new 클래스명(), new 클래스명()};
```
1. 객체 배열을 생성하면 참조변수의 값이 null로 초기화 되어 있고, 크기가 객체배열 크기인 객체가 저장되어 있다.   
   이후, 각각의 배열 인덱스에 인스턴스를 생성해서 주소를 저장할 수 있다.
2. 객체 배열 생성시 초기화 블럭을 사용하여 한번에 객체 생성까지 할 수 있다.

> 여러 종류의 객체를 하나의 배열에 저장할 수 있는 방법은 없을까?   
> -> 다형성(polymorphism)을 사용하면 하나의 배열로 여러 종류의 객체를 다룰 수 있다.

### 클래스의 또 다른 정의
> 객체지향이론에서의 클래스 : 객체를 생성하기 위한 틀   
프로그래밍에서의 클래스 : 데이터와 함수의 결합
1. 클래스 - 데이터화 함수의 결합
   * 변수 : 하나의 데이터를 저장할 수 있는 공간
   * 배열 : 같은 종류의 여러 데이터를 하나의 집합으로 저장할 수 있는 공간
   * 구조체 : 서로 관련된 여러 데이터를 종류에 관계없이 하나의 집합으로 저장할 수 있는 공간
   * 클래스 : 데이터와 함수의 결합 (구조체 + 함수)
2. 클래스 - 사용자정의 타입(user-defined type)
   * 기본형은 8개로 정해져 있지만 참조형의 경우 프로그래머가 자유롭게 추가할 수 있기 때문에 개수가 정해져 있지 않다.

## 3. 변수와 메서드
### 3.1 선언위치에 따른 변수의 종류
변수의 종류
* 클래스 변수 : 멤버변수 중 static이 붙은 변수, 클래스가 메모리 올라갈 때 생성
* 인스턴스 변수 : 멤버변수 중 static이 붙지 않은 변수, 인스턴스가 생성되었을 때 생성
* 지역 변수 : 멤버 변수외의 변수, 클래스 영역 이외의 영역에 선언되어 있는 변수(메서드, 생성자, 초기화 블럭), 변수 선언문이 수행되었을 때 생성

### 3.2 클래스변수와 인스턴스 변수
> 인스턴스변수는 인스턴스가 생성될 때 마다 생성되므로 인스턴스마다 각기 다른 값을 유지할 수 있지만, 클래스 변수는 모든 인스턴스가 하나의 저장공간을 공유하므로 항상 공통된 값을 갖는다.

### 3.3 메서드
> 메서드는 특정 작업을 수행하는 일련의 문장들을 하나로 묶은 것이다.
> 기본적으로 수학의 함수와 유사하며, 어떤 값을 입력하면 해당 값으로 수행한 결과를 반환한다.

메서드를 사용하는 이유
1. 높은 재사용성(reusability) : 한번 만들어 놓은 메서드는 몇 번이고 호출할 수 있으며, 다른 프로그램에서도 가능하다. (Java API)
2. 중복된 코드의 제거 : 같은 내용의 문장들이 여러 곳에서 반복해서 나타나곤 하는데 이런 반복되는 문장들을 하나의 메서드로 작성해 놓으면, 반복되는 문장들 대신 메서드를 호출하는 한 문장으로 대체할 수 있다.
   코드의 중복이 제거되고, 변경사항 발생 시 해당 메서드만 수정하면 되므로 관리가 쉽고 오류의 발생가능성도 낮아진다.
3. 프로그램의 구조화 : 문장들을 작업단위로 나눤서 여러 개의 메서드에 담아 프로그램의 구조를 단순화 시크는 것이 필수적이다. 처음에 프로그램을 설계할 때 내용이 없는 메서드를 작업단위로 만들어 놓고, 하나씩 완성해가는 것도 프로그램을 구조화하는 좋은 방법이다.
### 3.4 메서드의 선언과 구현
메서드는 크게 선언부와 구현부로 나누어져 있다.
* 메서드 선언부 : 메서드의 이름, 매개변수 선언, 반환타입으로 이루어져 있다.
  * 매개변수 선언 : 메서드가 작업을 수행하는데 필요한 값들을 제공받음 (변수의 타입이 같아도 변수의 타입을 생략할 수 없음)
  * 메서드의 이름 : 메서드는 특정 작업을 수행하므로 메서드의 이름은 'add'처럼 동사인 경우가 많으며, 이름만으로도 메서드의 기능을 쉽게 알 수 있도록 함축적이며 의미있는 이름을 짓도록 노력해야 한다.
  * 반환 타입 : 작업 수행의 결과물의 타입을 적어야 한다. 반환값이 없는 경우 void를 적는다.
* 메서드 구현부 : 메서드 선언부 다음 오는 {}를 메서드의 구현부라고 한다. 여기에는 메서드를 호출했을 때 수행될 문장들을 넣는다.
    * return 문 : 반환타입이 void가 아닌 경우 구현부 안에 반드시 return이 포함되어 있어야 한다. 이때, 반환하는 값은 **반환 타입과 일치하거나 자동 형변환이 가능**해야 한다. 
    * 지역변수 : 메서드 내에 선언되 변수들은 그 메서드 내에서만 사용할 수 있는 지역변수이다. 다른 메서드라면 같은 변수명을 사용해도 문제 없다.

### 3.5 메서드의 호출
메서드를 정의 했어도 호출되지 않으면 아무 일도 일어나지 않는다. 메서드는 다음과 같은 방법으로 호출할 수 있다.
```java
메서드이름(값1, 값2, ...);
```

#### 인자(argument)와 매개변수(parameter)   
메서드를 호풀할 때 괄호 안의 값들을 인자라고 하는데 인자의 개수와 순서는 호출된 메서드 선언부의 매개변수와 일치하거나 자동 형 변환이 가능해야 한다.

#### 메서드의 실행 흐름
같은 클래스 내의 메서드끼리는 참조변수를 사용하지 않고도 서로 호출할 수 있지만 static 메서드는 같은 클래스 내의 인스턴스 메서드를 호출할 수 없다.

클래스의 메서드 호출과정
1. main 메서드에서 메서드를 호출한다.
2. 호출시 지정한 값이 메서드의 매개변수로 복사된다.
3. 메서드 구현부의 내용이 순서대로 동작한다.
4. return을 만나거나 메서드의 모든 문장이 실행되면, 호출한 메서드로 돌아와서 이후의 문장을 실행한다.

메서드를 호출한 결과가 바로 변수에 저장되는 것이 아니라 반환값이 자리를 대신하고 이후 대입연산자로 변수에 저장된다.

### 3.6 return 문
return 문은 현재 실행중인 메서드를 종료하고 호출한 메서드로 되돌아간다. 반환값 유무와 상관없이 return문은 필요하지만 반환값이 없는 경우 컴파일러가 메서드의 마지막에 return을 자동으로 추가해주어 별 문제가 없었다.   
void가 아닌 경우 return문이 없다면 컴파일 에러 (error: missing return statement)가 발생한다.

#### 반환값(return value)
return 문의 반환값으로 주로 변수가 오긴 하지만 항상 그런 것은 아니다. 수식이 오는 경우 계산 결과를 반환한다.

#### 매개변수의 유효성 검사
메서드의 구현부를 작성할 때, 제일 먼저 해야 하는 일이 매개변수의 값이 적절한 것인지 확인하는 것이다.
메서드를 작성하는 사람은 '호출하는 쪽에서 알아서 적절한 값을 넘겨주겠지'라는 생각을 절대로 가져서는 안 된다.

## 3.7 JVM 메모리 구조
응용프로그램이 실행되면 JVM은 시스템으로부터 프로그램을 수행하는데 필요한 메모리를 할당받고 JVM은 이 메모리를 용도에 따라 여러 영역으로 나누어 관리한다.

* method area : 프로그램 실행 중 어떤 클래스가 사용되면, JVM은 해당 클래스의 클래스파일(*.class)을 읽어서 분석하여 클래스에 대한 정보(클래스 데이터)를 이곳에 저장한다. 이 때, 그 클래스의 클래스변수(class variable)도 이 영역에 함께 생성된다.
* call stack : 메서드 작업에 필요한 메모리 공간을 제공한다. 메서드가 호출되면, 호출스특에 호출된 메서드를 위한 메모리가 할당되며, 이 메모리는 메서드가 작업을 수행하는 동안 지역변수들과 연산의 중간결과 등을 저장하는데 사용된다. 그리고 메서드가 작업을 마시쳔 할당되었던 메모리 공간은 반환되어 비원진다.
* heap : 인스턴스가 생성되는 공간. 프로그램 실행 중 생성되는 인스턴스는 모두 이곳에 생성된다.
