라이브러리, 디자인 패턴, 프레임 워크가 무엇인지? 무엇이 다른지 설명하시오

주도권 차이 모듈이 전체적인 주도권을 가지느냐 프레임 워크가 

모듈을 떼어내서 공통적으로 사용하는 것이다.

# 싱글톤 패턴

## 싱글톤 패턴이란?

- 하나의 클래스에 오직 하나의 인스턴스만 가지는 패턴
- DB 연결 모듈에 많이 사용함
- 장점 : 인스턴스 생산 비용이 감소함
- 단점 : `의존성`이 높아짐

고정된 메모리 영역ㅇ을 사용하기 때문에 관리하기 쉽고

전역으로 사용되다 보니까 다른 클래스로부터 접근이 자유롭고 데이터 공유가 쉽다.

`solid`

`싱글톤으로 만들어진 객체는 DIP를 어기고 → OCP 또한 생성하였기 떄문에` 

Java Script의 ==과 ===의 차이점

[자바스크립트: '==' 와 '===' 는 다르다!](https://velog.io/@filoscoder/-%EC%99%80-%EC%9D%98-%EC%B0%A8%EC%9D%B4-oak1091tes)

- 자바의 Sycronized
    
    ## **Java 로 동기화를 해보자!**
    
    동기화는 프로세스(스레드)가 수행되는 시점을 조절하여 서로가 알고 있는 정보가 일치하는 것
    
    프로세스 간 데이터가 일치하도록 하는 것
    
    동기화 메커니즘인 상호배제는 프로세스들이 필요로 하는 자원에 대해 배타적인 통제권을 요구하는 것
    
    하나의 프로세스가 공유자원을 사용할 때 다른 프로세스가 동일한 공유자원에 접근할 수 없도록 통제하는 것
    
    상호배제 방법으로는 Mutex, Semaphore 방식
    
    Java 에서는 Monitor 라는 도구를 통해 객체에 Lock 을 걸어 상호배제
    
    Mutex
    여러 스레드를 실행하는 환경에서 자원에 대한 접근에 제한을 강제하기 위한 동기화 메커니즘
    
    Boolean 타입의 Lock 변수
    
    1개의 공유자원에 대한 접근을 제한
    
    공유자원을 사용 중인 스레드가 있을 때, 다른 스레드가 공유자원에 접근한다면 Blocking 후 대기 큐
    
    Lock 을 건 스레드만 Lock 을 해제할 수 있다.
    
    Semaphore
    멀티프로그래밍 환경에서 다수의 프로세스나 스레드가 n 개의 공유 자원에 대한 접근을 제한하는 방법으로 사용되는 동기화 기법
    
    n 개의 공유자원에 대한 접근을 제한할 수 있으며 이를 계수 세마포어라고 한다.
    
    접근 가능한 공유 자원의 수가 1개일 때는 이진 세마포어로 뮤텍스처럼 사용할 수 있다.
    
    세마포어 변수를 통해 wait, signal 을 관리한다. 세마포어 변수는 0 이상의 정수형 변수를 갖는다.
    
    큐에 연결된 스레드를 깨우는 방식에 따라 강성 세마포어(큐에 연결된 스레드를 깨울 때 FIFO 정책), 약성 세마포어(큐에 연결된 스레드를 깨울 때 순서를 특별히 명시하지 않음)로 구분된다.
    
    Lock 을 걸지 않은 스레드도 Signal 을 보내 Lock 을 해제할 수 있다.
    
    Semaphore 는 완벽한 상호배제를 제공한다고 할 수 없기 때문에 이를 보완까지 해둔 Monitor 를 사용하면 훨씬 쉽게 동기화를 사용할 수 있다.
    
    Monitor
    
    세마포어는 wait & signal 연산 순서를 바꿔서 실행하거나 둘 중 하나라도 생략하면 상호배제를 위반하는 상황이나 교착 상태가 발생
    
    이러한 단점을 극복하기 위해 모니터가 등장
    
    모니터는 프로그래밍 언어 수준에서 제공된다. 대표적으로 Java 에서 제공한다. 순차적으로 사용할  수 있는 공유 자원 혹은 공유 자원 그룹을 할당하는 데 사용된다. 모니터는 이진 세마포어만 가능하다.
    
    공유 자원에 점유 중인 프로세스(스레드)는 Lock 을 가지고 있다.
    
    공유 자원을 점유 중인 프로세스(스레드)가 있는 상황에서 다른 프로세스(스레드)가 공유 자원에 접근하려고 하면 외부 모니터 준비 큐에서 진입을 wait 한다.
    
    Monitor 는 Semaphore 처럼 signal 연산을 보내는  것이 아니라 조건 변수를 사용하여 특정 조건에 대해 대기 큐에 signal 을 보내 작업을 시작시킨다.
    
    `runable`
    

일단 멈춤 해당 내용에 대해서는 추후에 다시 공부하기

# 팩토리 패턴

## 팩토리 패턴이란?

객체 생성 부분을 떼어내 추상화한 패턴

상속 관계에 있는 두 클래스에서 

- 상위 클래스가 중요한 뼈대를 결정
- 하위 클래스가 객체 생성에 관한 구체적인 내용을 결정하는 패턴

## 장점

- 상위 클래스에서는 인스턴스 생성 방식을 알 필요가 없기 떄문에 더 많은 유연성을 가짐
- 객체 생성 로직이 따로 떼어져 있기 때문에 코드를 리팩토링 하더라고 한 곳만 고칠 수 있게 되니 유지 보수성이 증가함

커피 머신에 커피를 내릴 때

아메리카노, 콜드 브루, 와 같은 이름 만 넣으면 만들어도 동작이 SSG 팩토리 패턴을 봐서 잘 이해하고 있다.

# 전략 패턴

## 전략 패턴이란?

전략(strategy) 혹은 정책(policy) 패턴이라고 하며, 객체의 행위를 바꾸고 싶은 경우 `직접` 바꾸지 인ㄹ고

행위를 직접 수정하지 않고 전략이라고 부르는 캡슐화한 알고리즘을 컨텍스트 안에서 바꿔주면서 상호 교체가 가능하게 만드는 패턴

Oauth 와 같이 같은 방식으로 다양한 서비스가 지원하는 경우 전략패턴을 통해 사용 가능하다

 명변 패턴(다른거) ???

직접 메서드를 호출하는 것이 아니라,

어플리케이션 컨텍스트→ 인터페이스ㅡㄹ 구현하는 구현체가 다양하게 있다. 

결국 수행하는 내용이 어플리케이션 인스턴스 안에 이쓴ㄴ 내용들ㄹ이고 구현체를 바꿔줌으로써 동작하는 

# 옵저버 패턴

주체가 어떤 객체의 상태 변화를 관찰하다가 상태 변화가 있을 때 마다 메서드 등을 통해 옵저버 목록에 있는 옵저버들에게 변화는 알려주는 디자인 패턴

옵저버 패턴은 프록시 객체를 통해 구현이 가능함

프록시 객체 : 기본적인 동작 ( 속성 접근, 할당, 순회, 열거, 함수 호출 등)의 작업을 가로챌 수 있는 객체를 의미함, 자바 스크립트에서 프록시 객체는 두 개의 매개 변수를 가짐( target : 프록시할 대상,  handler : 프록시 객체의 target 동작을 가로채서 정의할 동작들이 정해져 있는 함수)

리액트에서 단반향 바인딩 : 대표적 옵저버 패턴 모델에서 값이 변경되었을 떄, 컨트롤러가 비지니스를 통해 값을 던져주는 것이 

다른객체에서 

주체가 다른 객체에 이벤트를 발생시키는 것이아니라 다른 객체에 이벤트가 발생했을 때 가져올 수 있는 (주도권??? 방향??? )

트위터, 채팅들 이런 것들도 옵저버 패턴이다.

옵저버 패턴을 극적으로 사용한 것이 리액트 단반향 바인딩이다.

rest api 는 이벤트를 직접 발생시켜서 서버에 요청을 보내는 것인데

데이터만 바꾸고 바꾼것을 확인한 후에 

트위터 → 누군가 피드를 새로 올리면 그 사람을 구독한 사람들에게도 전달해줘야 한다.

상속이란? 부모 클래스의 메서드를 상속받아서 확장

임플리먼츠는 부모를 재정의 해서 실제로 구현하는 것

프록시 객체

# 프록시 패턴과 프록시 서버

프록시 백엔드 대표 내용 인터셉터, 필터, AOP, 스프링 컨테이너 CGLIB

프록시 패턴은 대상 객체에 접근하기 전 그 접근에 대한 흐름을 가로체 대상 객체 앞단의 인터페이스 역활을 하는 디자인 패턴

⇒ 객체의 속성 변환 등을 보완하며 보안, 데이터 검증, 캐싱, 로깅에 사용한다.

캐시 안에 정보를 담아두고, 캐시 안에 있는 정보를 요구하는 요청에 대해 다시 저 멀리 있는 원격 서버에 요청하지 않고 캐시 안에 있는 데이터를 활용하는 것을 말한다. 이를 통해 불필요하게 외부와 연결하지 않기 때문에 트래픽을 줄일 수 있다는 장점이 있다.

프록시 서버로 쓰는 CloudFlare

전 세계적으로 분산되 서버가 있고 이를 통해 어떠한 시스템의 콘텐츠 전달을 빠르게 할 수 있는 CDN 서비스

미국에서 요청해서 망 사용료를 내다 보니ㄲ까

ISP 

국내에 CDN 서버를 생성하고 자주 보는 요청에 대해서 효율적 

# 이터레이터 패턴

접근 제어자

abstract

public, private, package(default), protected

# MVC 패턴

모델

MVC1 → jsp 컨트롤러(서블릿)을하나로

MVC2 → 컨트롤러에서 서블릿이 분리되어 있고 각각이 분리되어 있는

# MVP

모델 

프레젠터 뷰 1:1 관계여서 더 강하게 연결되어 있다.

# MVVM

양방향 바인딩 

뷰모델과 뷰 양방향 바인딩 양방햔 바인딩에 대해서 좀 더 깊게